### 选择题(第五题和答案不太一样)

**1.D**

接口允许多继承，能很好地弥补类只能单继承的缺陷



**2.D**

+ 接口中的方法不能有方法体，哪怕是空的也不行
+ print()后面没加；
+ 一个接口允许继承于多个接口，但要用用implements来表示，extends是类继承的关键字

```java
public interface 接口名{
    成员变量; //java编译时自动加上public static final，将其默认为常量
    成员方法;//java编译时自动加上public abstract,将其默认为抽象方法
}
```



**3.B**

super语句必须妨碍构造器的第一行



**4.A**



**5.ABC**



**6.D**

在Base类里面没有methodB方法，如果想要调用methodB方法，要么就在Base里声明一个methodB，要么直接用Child base = new Child();来创建对象



**7.C**

p是个Student对象，但是Student继承于Person，Person继承于Object，所以p也是Person和Object类型的对象



**8.ABD**

+ java接口中不能声明私有成员，接口就是用来实现的，所以里面的成员变量和成员方法都只能是public的



**9.D**		

包含抽象方法的类必须定义为抽象类，抽象类不能创建对象，仅作为一种特殊的父类用于被子类继承和实现，一个类继承了抽象类，那么必须重写完抽象类中的抽象方法，否则这个类也必须被定义为抽象类

+ 没有重写void draw()；方法，重写要求返回类型，函数名，参数列表都是一致的
+ B不知道为什么不对
+ 要么把draw声明为abstract的，要么给draw加上方法体



**10.A**

这题代码有点问题，Penguin没写extends Animal，代码里的super.name应该改成name

主函数在加载类的时候会加载Animal类和Penguin类，创建对象时调用Penguin的构造器，由于Penguin的无参构造器的第一行调用了Animal的构造器，并且传入了一个String，所以会调用Animal的有参构造器，将pgn的name设置为“小可爱”。



**11.BD**

+ 抽象类不能被实例化，只能用来被其他类实现
+ 抽象类中不一定要有抽象方法



**12.A**





### 今日单词

1. 判断左边的对象，是否是右边的类型的关键字：instanceof
2. 调用父类成员关键字：super
3. 定义抽象类的关键字：abstract
4. 定义常量关键字：final
5. 定义接口关键字：interface
6. 实现接口关键字：implements





### 简答题

1. **什么是多态？多态的好处和弊端分别是什么？如何解决弊端？**

   答：

   + 多态分为对象多态和方法多态，对象多态指的是一个对象可以被看做多个类型的实例，方法多态指的是可以根据所调用的对象不同而表现出不同的行为。
   + 多态的好处是，在多态下，模块是解耦合的，更加便于扩展和维护；多态的弊端是不能调子类特有的方法。要解决这个问题需要用到强制类型转换。

   

2. **abstract不能和哪些关键字共存？为什么？**

   答：不能和private，final共存。因为一个方法用private修饰，则说明它是私有的，而abstract修饰的方法是要被继承并且实现的。同理，final修饰的方法说明方法是最终的，不能再被改变的，所以不能被abstract修饰。

   

3. **抽象类和普通父类有何区别？为什么要定义抽象父类？**

   答：抽象类不可以被实例化，其中的抽象方法必须在子类中被重写。普通父类可以被实例化，其中的方法可以被子类选择性地重写。抽象父类可以隐藏内部的实现细节，只为外部用户提供更为简洁的接口，降低使用的复杂性。

   

4. **final关键字能修饰哪些成员？各自特点是什么？**

   答：可以修饰类，方法，变量。修饰类的时候类不能被继承，修饰方法的时候方法不可以被重写，修饰变量的时候变量只能被赋值一次。

   

5. **如何调用父类构造器？调用父类构造器的目的？**

   答：super(参数列表)。调用父类构造器是为了完成父类定义的初始化工作，确保父类的初始化逻辑得以执行，并传递相应的参数给父类构造器。

   

6. **接口和抽象类有何区别？**

   答：抽象类里可以有构造器，变量等普通类里可以包含的组成部分，但接口中只能有成员变量（常量）和成员方法（抽象方法）。





### 排错题

1. 有问题，接口C继承了接口A和B，这两个接口里都有方法show()，所以接口C需要对show()方法进行重写
2. 有问题，接口A和类B中都有变量x，类C继承了B，实现了A，所以不清楚x指的到底是哪个x。可以用A.x指明来自接口A的x，super.x指明来自类B的x
3. 没有问题





### 代码题

略

