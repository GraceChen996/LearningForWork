## 选择题

**1.B**

**2.AD**

+ 外部类不能直接访问非静态内部类的成员，需要通过建立内部类实例才可以访问



**3.D**



**4.C**

List已经被声明只能加入String类型的变量，而100不是String类型的



**5.ABDG**

静态方法是属于类本身的，而不是属于类的实例，静态方法随着类的加载而加载，此时泛型还没传递真正的参数，因此在静态方法中无法直接引用泛型类型 T。所以 

```
static T y;
static T s1() {return null;}
static void s2(T i) {}
```

这种形式都是错误的。如果静态方法需要使用泛型参数，可以将泛型参数定义在方法上。



**6.D**

匿名内部类没有类名，所以自然不能有构造方法



**7.D**

**8.CD**

+ A，a是一个非静态变量，A中的methodA是一个静态方法，里面不能包含非静态变量

+ B，同理，静态方法中不能包含非静态变量

+ E，同理同理同理

  

**9.D**

不用标识继承关系，所有类默认继承Object类



**10.C**

**11.BC**

+ Byte首字母都大写了，一看就是引用数据类型
+ 基本数据类型不算一个类，怎么可能可以调用方法。



**12.D**

因为i没有赋值，所以会抛出一个空指针错误，空指针错误属于运行错误



## 今日单词

1. 枚举关键字：enum
2. Object类中各个的方法名称：toString(); equals(Object o); clone()
3. JDK八种包装类类名：Byte, Short, Integer, Long, Character, Float, Double, Boolean





## 简答题

1. **静态内部类的加载时机？**

   答：静态内部类的加载是在程序中调用静态内部类的时候加载的，和外部类的加载没有必然关系。在加载静态内部类时，如果发现外部类没有加载，那么会先加载外部类，加载完外部类（静态变量，静态代码块...）后再加载内部类。

   

2. **什么是枚举？枚举同静态常量有何区别？**

   答：枚举是一种特殊的数据类型，用于定义包含固定常量集合的类型。

   和静态常量相比：

   + 枚举限定了取值范围。当使用枚举时，只能使用预定义的常量，而静态常量可以为任意值

   + 枚举提供了更好的类型安全性。编译器可以检查枚举常量是否合法，而对静态常量则无法做到这点
   + 枚举提供了更好的可读性。当使用枚举时，可以直接通过枚举类型来访问常量，而静态常量需要通过类名来访问，可读性较差。

   

3. **什么是泛型？有几种泛型定义方式？**

   答：

   + 泛型是一种编程范式，它允许在定义类、接口和方法时使用类型参数，使得在编译阶段可以约束操作的类型。
   + 有三种泛型定义方式

   ```java
   //泛型类
   修饰符 class 类名<类型变量，类型变量，...>{
   
   }
   ```

   ```java
   //泛型接口
   修饰符 interface 接口名<类型变量，类型变量，...>{
   
   }
   ```

   ```java
   //泛型方法
   修饰符 <类型变量，类型变量,...> 返回值类型 方法名(形参列表){
   
   }
   ```

   

   

4. **泛型注意事项什么？**

   答：

   + 泛型是工作在编译阶段的，一旦编译成class文件后，文件中就不存在泛型了，这就是所谓的泛型擦除。
   + 泛型不支持基本数据类型

   

5. **什么是浅克隆？什么是深克隆？**

   答：

   + 浅克隆：在对对象进行克隆操作的时候，直接拷贝基本数据类型，拷贝引用数据类型（包括String）的地址
   + 深克隆：在对对象进行克隆操作的时候，直接拷贝基本数据类型，拷贝引String的地址，给其他引用数据类型创建新的对象

   

6. **JDK提供的包装类有什么作用？**

   答：

   + 更加符合Java一切皆可对象的思想，将基本数据类型也变成了对象
   + 支持泛型。在使用泛型时，只能使用引用数据类型，而不能使用基本数据类型，包装类将基本数据类型转换成了引用数据类型，更好地支持了泛型
   + 使得Java可以更加地对基本数据类型进行处理

## 排错题

1. 没问题

2. true；false

   在Java中，对于Integer对象，当它们的值在-128到127之间时，它们会被缓存并重用。所以对于i和i2，它们的值都在这个范围内，所以它们在内存中是同一个对象，所以输出为true。

3. 匿名内部类中不能定义静态方法

4. **在Java中，内部类不能直接扩展外部类**。主函数中，要创建一个Demo1的对象，首先要调用Demo1的构造函数，Demo1构造函数的第一行需要调用Inner的构造函数，Inner又继承于Demo1，所以要加载Demo1。

