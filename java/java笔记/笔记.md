# Java基本知识

## JDK和JRE

JDK（Java Develoment Kit）：Java开发工具包

+ JRE（Java Runtime Enviroment）：Java的运行环境

  + JVM（Java Virtual Machine）：Java虚拟机，真正运行Java程序的地方

  + 核心类库：Java自己写好的程序，给程序员自己的程序调用的

+ 开发工具



1. 写好的程序test.java通过javac被编译成test.class
2. test.class被java送入JVM运行
3. JVM通过调用核心类库里的程序运行用户提供的程序



## Java跨平台的工作原理

不同平台有不同的JVM虚拟机，JAVA程序通过javac编译成Class文件后就可以在不同的虚拟机上运行





## IDEA快捷键

main/psvm，sout...:快捷输入相关代码

Ctrl + D：复制当前数据到下一行

Ctrl + Y：删除所在行，建议用Ctrl + X

Ctrl + ALT + L：格式化代码

ALT + SHIFT + 上，ALT + SHIFT + 下：上下移动当前代码



## Java内存分配

+ 方法区域
+ 栈：方法运行时进入的内存，变量也存储在这里
+ 堆：new出来的东西



# 面向对象

## 对象和类

### 类：具备某些共同特征的实体的集合



在一个类中可以包含以下类型的变量：

+ 局部变量：在方法、构造方法、或是语句块中定义的变量。方法结束后变量自动销毁。

+ 成员变量：在类中，但在方法外的变量。**在创建对象是被实例化**。
+ 类变量：在类中，但在方法外的变量，必须被生命为static类型。



每个类都有构造方法，可以有多个，如果没有显示提供，Java编译器会提供一个默认的构造方法。在创建对象时至少要调用一个构造方法，且构造方法必须与类同名。



### 创建对象

1. 声明：声明一个对象，包括其名称和类型
2. 实例化：用关键字new创建一个对象
3. 初始化：用new创建对象时调用构造方法初始化对象

```
public class Puppy{
   public Puppy(String name){
      System.out.println("小狗的名字是 : " + name ); 
   }
   public static void main(String[] args){
      // 下面的语句将创建一个Puppy对象
      Puppy myPuppy = new Puppy( "tommy" );
   }
}
```



### 访问实例变量和方法

```
/* 实例化对象 */
Object referenceVariable = new Constructor();
/* 访问类中的变量 */
referenceVariable.variableName;
/* 访问类中的方法 */
referenceVariable.methodName();
```



### 源文件声明规则

1. 一个源文件中只能有一个 public 类，且名称应与public 类的类名保持一致

2. 一个源文件可以有多个非 public 类

3. 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行

4. 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。

5. import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。

   ```
   #文件名 MyClass.java
   
   package com.example.mypackage;
   
   import java.util.List;
   
   public class MyClass{
   
   }
   
   class MyOtherClass1{
   
   }
   
   class MyOtherClass2{
   
   }
   ```

   

### this

this就是一个对象，用在方法中来拿到当前对象。

用来解决对象的成员变量与方法内部变量名称一致所导致的访问冲突问题



## Java基本数据类型

### 内置数据类型（6+1+1）

+ byte：8位、有符号、以二进制补码表示的整数；表示范围为（-128,127），默认值是0，用于大型数组中节约空间。
+ short：16位、有符号、以二进制补码表示的整数；表示范围为（-32768，32767），默认值是0，也可以像 byte 那样节省空间。
+ int：32位、有符号、以二进制补码表示的整数；表示范围为（-2147483648**，**2147483647），默认值是0
+ long：64 位、有符号、以二进制补码表示的整数；表示范围为（9223372036854775808，-9223372036854775807），默认值是 0L。
+ float：单精度、32位、符合IEEE 754标准的浮点数；**不能表示精确的值**
+ double：双精度、64 位、符合 IEEE 754 标准的浮点数；**浮点数的默认类型**，**不能表示精确的值**
+ boolean：默认值是false
+ char：16位Unicode字符

```
数据类型：Byte，Short，Integer，Long，Float，Double，Character
查看最小值：数据类型.MIN_VALUE
查看最大值：数据类型：MAX_VALUE
```



### 引用数据类型

引用，数组，都是引用数据类型，其默认值都是null。一个引用变量可以用来引用任何与之兼容的类型

```
Site site = new Site("Runoob")
```



### Java常量

在java中用final关键字来修饰常量，声明方式与变量类似，常量名通常用大写字母表示



### 自动类型转换

转换等级从低到高：

byte，short，char -> int -> long -> float -> double



数据类型转换满足以下转换规则：

- 不能对boolean类型进行类型转换。
- 不能把对象类型转换成不相关类的对象。
- 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。
- 转换过程中可能导致溢出或损失精度
- **浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入**



1. 自动类型转换

   转换前的数据类型的位数要低于转换后的数据类型

2. 强制类型转换

   转换的数据类型必须是兼容的

3. 隐含强制类型转换

   整数默认类型int；小数默认类型double，在定义float类型时必须在后面跟上f或者F



## Java变量类型

变量声明基本格式：

```
type identifier [ = value][, identifier [= value] ...] ;
```



+ 局部变量（Local Variables）：定义在方法、构造方法或语句块中的变量，作用域仅限于当前方法、构造方法或语句块。不能被访问修饰符修饰。**不能被访问修饰符修饰**。
+ 成员变量（Instance Variables）：定义在类中、方法之外的变量，作用域为整个类，可以被类中的任何方法、构造方法或语句块访问。**可以被访问修饰符修饰**。
+ 静态变量（Class Variables）：定义在类中、方法之外的变量，用static关键字修饰，作用域为整个类。**可以被访问修饰符修饰**。在程序运行期间只有一个副本
+ 参数变量（Parameters）：调用方法时传递给方法的值，作用域仅限于方法内部。



### 局部变量

- 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。
- 局部变量只在声明它的方法、构造方法或者语句块中可见，不能被其他方法或代码块访问。
- 局部变量没有默认值，声明后必须经过初始化才能使用。声明时如果没有初始化，变量会被赋予默认值。
- 局部变量是在**栈上**分配的

```
type variableName
```





### 静态变量

+ 静态变量在类加载时被创建，在整个程序运行期间都存在。
+ 由于静态变量是与类相关的，因此可以通过类名来访问静态变量，也可以通过实例名来访问静态变量
+ 用来存储整个程序都需要使用的数据，如配置信息、全局变量等。
+ 和常量的区别：常量一旦被赋值就不能再修改，在编译时就已经确定了值，而静态变量在运行时可以改变。
+ 静态变量是属于类的，而不是对象的实例，在内存中只有一份拷贝，被所有实例共享。因此，当**多个线程同时访问一个包含静态变量的类时**，需要考虑其线程安全性。



### 成员变量

+ 当一个对象被实例化之后，每个成员变量的值就跟着确定。
+ 成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。
+ 访问修饰符可以修饰成员变量，一般情况下应该把成员变量设为私有。通过使用访问修饰符可以使成员变量对子类可见。

```
accessModifier type variableName;
```



### 参数变量

参数变量与局部变量类似，但它们只在方法或构造函数被调用时存在，并且只能在方法或构造函数内部使用。

参数传递方式：

	+ 值传递：传递的是实际参数的值的副本，参数变量被赋新值时只会修改副本的值不会影响原值，基本数据类型都采用值传递方式传递参数变量的值。基本数据类型都采用值传递方式传递参数变量的值。
	+ 引用传递：在方法调用时，传递的是实际参数的引用（即内存地址）。参数变量被赋予新的值时，会修改原始值的内容。对象类型采用引用传递方式传递参数变量的值。



## Java修饰符

### 访问控制修饰符

| 访问权限  | 可见性                       | 适用对象             | 备注           |
| --------- | ---------------------------- | -------------------- | -------------- |
| default   | 同一包内可见                 | 类、接口、变量、方法 |                |
| private   | 同一类内可见                 | 变量、方法           | 不能修饰外部类 |
| public    | 对所有类可见                 | 类、接口、变量、方法 |                |
| protected | 对同一包内的类和所有子类可见 | 变量、方法           | 不能修饰外部类 |

### 非访问修饰符

+ static

  静态变量：无论一个类实例化多少对象，它的静态对象只有一份拷贝

  静态方法：独立于对象的方法，不能使用类的非静态变量

+ final

  final变量：和static修饰符一起使用来创建类常量

  final方法：可以被子类继承，但不能被子类重写，可以有效防止方法中的内容被修改

  final类：不能被继承

+ abstract

  抽象类：声明抽象类的唯一目的就是为了将来对该类进行扩充，一个类不能同时被abstract和final修饰。如果一个类中包含了抽象方法，那么这个类一定要被声明为抽象类。抽象类中可以包含抽象方法和非抽象方法，也可以不包含抽象方法。

  抽象方法：没有任何实现的方法，不能被声明成final和static，任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。抽象方法的声明以分号结尾，例如：**public abstract sample();**

+ synchronized

  该关键字声明的方法同一时间只能被一个线程访问

+ transient

  序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。

+ volatile

  每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。当成员变量发生变化时，会强制线程将变化值回写到共享内存。



# 常用API

## String

### 注意事项

1. String的对象是不可变的：字符串每次进行值更改的时候，实际上都是产生了新的字符串对象
2. 以“...”写出的字符串对象会存储到字符串常量池中，且相同内容的字符串只会存储一份
3. 通过new方式创建字符串对象，每new一次都会产生一个新的对象



### 常见构造器

1. public String()：String name = new String();
2. public String(String original): String name = new String("heiheihiehi");
3. public String(char[] chars):String name = new String(chars);
4. public String(byte[] types):String name = new String(types);



### 常见方法

+ int length
+ char charAt
+ char[] toCharArray //字符串转化成字符数组
+ boolean equals
+ boolean equalsIgnoreCase //忽略大小写比较字符串内容
+ String substring(int beginIndex,int endIndex) //[)，右边是开区间
+ String substring(int beginIndex) //当前索引一直到字符串结尾
+ String replace（CharSequence target，CharSequence replacement） 
+ boolean contains（charSequence s）//判断是否包含关键字
+ boolean startsWith（String prefix）//判断字符串是否以某个字符串开头
+ String[] split（String regex） //按指定内容分割成多个字符串，放到一个字符串数组中返回给我们





## ArrayList

### 常见方法

+ public boolean add(E e)
+ public void add(int index, E element)
+ public E get(int index)
+ public int size()
+ public E remove(int index)
+ public boolean remove(Object o)
+ public E set(int index,E element)



# 面向对象高级

## static 

**成员变量分类：**

+ 类变量：属于类，被static修饰，在计算机中只有一份，会被类的全部对象共享
+ 实例变量：属于每个对象



**成员方法分类：**

+ 类方法：有static修饰的成员方法，属于类
+ 实例方法：无static修饰的成员方法，属于对象

工具类中的方法用类方法创建，可以不用创建对象，从而节省了内存。最好对工具类的构造器进行私有化，防止从外部进行工具类对象的创建



**代码块分类：**

+ 静态代码块：类加载时自动执行；用于完成类的初始化
+ 实例代码块：每次创建对象时，会执行实例代码块，并且在构造器之前执行；用于完成对象的初始化



**static的注意事项：**

	1. 类方法中可以直接访问类成员，但不可以直接访问实例成员
 	2. 实例方法可以直接访问类成员和实例成员
 	3. 实例方法中可以出现this关键字，但类方法中不可以出现this关键字



**static的应用知识：单例设计模式**

设计模式：一个问题通常有很多种解法，其中最优的解法就是设计模式，设计模式有二十多种

单例设计模式：确保一个类只有一个对象



**单例设计模式写法：**

（饿汉式）

				1. 把类的构造器私有化
   				2. 定义一个类变量记住类的一个对象
   				3. 定义一个类方法返回这个对象

```java
public class A{
    private static A a = new A();
    private A(){
        
    }
    public static A getObject(){
        return a;
    }
}
```



（懒汉式）

   				1. 把类的构造器私有化
   				2. 定义一个类变量用于存储对象，但此时不new
   				3. 定义一个类方法，通过if语句控制，确保只new一次对象，其余时候返回这个对象



```java
public class A{
    private static A a;
    private A(){
        
    }
    public static A getObject(){
        if(a == null){
            a = new A();
        }
        return a;
    }
}
```



## 继承

**继承的特点：**

 1. 子类可以继承父类的非私有成员（成员变量，成员方法）

 2. 子类的对象是由子类和父类共同完成的

    

### 继承相关的注意事项

**权限修饰符**：用于限制类中成员能够被访问的范围

![image-20231107105327973](C:\Users\83538\AppData\Roaming\Typora\typora-user-images\image-20231107105327973.png)

注意：protected是任意包下的子类里可以访问，如果在其他类里创建了子类对象，对象是没法访问protected成员的

**单继承**：Java不支持多继承，但支撑多层继承：A可以extends B，B extends C；但不可以A extends B，C；

**Object类**：Object是所有类的祖宗类

**方法重写**：

+ 当子类觉得父类中的某个方法无法满足自己的需求时，子类可以重写一个方法名称及参数列表一样的方法去覆盖父类的方法。重写后，方法的访问遵循就近原则。
+ 注意事项
  + 方法重写需要使用override进行注解，override可以帮助检查重写是否正确，提升代码可读性
  + 子类重写父类方法时，访问权限必须大于等于父类该方法的权限
  + 重写方法的返回值类型必须与被重写方法一样，或者范围更小
  + **私有方法，静态方法**不能被重写。
  + 在子类中访问其他成员是依照就近原则的，方法的局部变量>本类中的成员>父类中的成员，巧用this和super

**子类构造器：**

+ 子类的全部构造器都会先调用父类的构造器，再执行自己。（子类构造器的第一行默认有个super(),不写的时候也默认存在）
+ 如果父类没有无参构造器，那么不写super()就会报错，这个时候要手动写一个“super(参数)”来调用父类的有参构造器
+ 可以通过this（）调用兄弟构造器。this()和super()不能同时存在





## 多态

多态是在继承/实现情况下的一种现象。表现为：对象多态，行为多态。

+ 对象多态
+ 行为多态：编译看左边，运行看右边

**特别注意**：只强调对象和行为的多态性，不强调成员变量的多态性。

```
People p1 = new Teacher();
p1.run(); //编译的时候如果People里没有run方法，会报错（可以用抽象方法解决）。运行时运行的是Student的run方法
System.out.println(p1.name);//此处会打印People的name，而不是Student的name

Peopel p2 = new Teacher();
p2.run(); //编译的时候如果People里没有run方法，会报错（可以用抽象方法解决）。运行时运行的是Teacher的run方法
System.out.println(p2.name);//此处会打印People的name，而不是Teacher的name

Public class People{
	public String name = "人";
	public void run(){
		System.out.println("人都可以跑步");
	}
}

Public class Teacher extends People{
	Public String name="老师";
	public void run(){
		System.out.println("老师跑得慢");
	}
}

Public class Student extends People{
	Public String name="学生";
	public void run(){
		System.out.println("学生跑得快");
	}
}
```

**多态的前提**：

+ 有继承/实现的关系
+ 存在父类引用子类对象
+ **存在方法重写**



### 多态的好处

+ 在多态形势下，右边对象是解耦合的，更便于扩展和维护

+ 使用父类类型的形参可以接收一切子类对象，扩展性更强更便利

  

  ![image-20231113155051181](C:\Users\83538\AppData\Roaming\Typora\typora-user-images\image-20231113155051181.png)

  

**注意**：多态下是不能调用子类的独有功能的，此时需要进行强制类型转换，强制类型转换过程中如果发现对象的真实类型和强转的类型不同会报类型转换异常（ClassCastException）的错误，所以强转前一般建议用instanceof关键字判断类型后再进行强转



## final

+ final可以修饰（类，方法，变量）
+ 修饰类：不能被继承
+ 修饰方法：不能被重写
+ 修饰变量：只能被赋值一次

final如果修饰基本类型变量，变量存储的数据不能被改变；

final如果修饰引用类型的变量，变量存储的地址不能被改变，**但地址指向的内容是可以改变的**。



## 抽象类

抽象：用abstract修饰的类和方法称为抽象类和抽象方法，经常用来设计模板方法设计模式

**注意事项**：

+ 抽象类中不一定要有抽象方法，有抽象方法的类一定是抽象类
+ 抽象类不能创建对象，仅作为一种特殊的父类让子类继承并实现
+   一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类

***chy有话说：在父类里提前定义好抽象方法，更好地支持了多态。其实抽象方法并不是必须的，在父类里面可以直接写一个空方法体，子类中同样可以进行方法重写，但是这样就不会强制子类进行重写***



**模板方法设计模式**：解决方法中存在错误代码的问题

写法：

1. 定义一个抽象类
2. 在里面定义2个方法：模板方法（相同的代码），抽象方法（具体实现交给子类）

建议使用final关键字修饰模板方法，防止模板方法被子类重写



## 接口

接口：interface，接口里只能有成员变量和成员方法，不能有构造器等方法。

![image-20231114161102365](C:\Users\83538\AppData\Roaming\Typora\typora-user-images\image-20231114161102365.png)

接口中定义的成员变量会被java默认为常量，所以可以直接写，不用加public static final修饰；同样，方法会被默认为抽象方法，不用加abstract修饰。接口是不能被创建对象的，接口是用来被类实现的，实现接口的类叫实现类。

***chy有话说：接口有点像抽象类，甚至比抽象类更抽象，抽象类不能创建对象，则接口同样不能创建对象***



### 接口的好处

+ 弥补了类单继承的不足（一个类可以实现多个
+ 让程序可以面向接口编程，方便切换业务实现



### JDK8开始，接口中新增的三种方法

+ 默认方法：必须使用default修饰，默认会被public修饰（必须使用实现类的方法来调用，因为接口没有对象）
+ 私有方法：必须使用private修饰（JDK9开始支持）（只能在接口内部访问）
+ 静态方法：必须使用static修饰，默认会被public修饰

**为什么要新增方法**：增强了接口的能力，更便于项目的扩展和维护





### 接口的多继承

一个接口可以同时继承多个接口，便于实现类去实现

注意事项：

1. 一个接口继承多个接口，如果多个接口中存在方法签名冲突，此时不支持多继承

   ***chy有话说：也就是这个接口所继承的多个接口里有重名的方法***

2. 一个接口继承多个接口，如果多个接口中存在方法签名冲突，此时不支持多实现

   ***chy有话说：也就是这个接口所继承的多个接口里有重名的方法，并且这几个重名方法的返回值不同***

3. 一个类继承了父类，又实现了接口，父类和接口中有重名的默认方法，则实现类会优先使用父类的

4. 一个类实现了多个接口，多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可



## 内部类

如果一个类定义在另一个类的内部，那这个类就是内部类

1. 成员内部类：类中的一个普通成员
2. 静态内部类
3. 局部内部类
4. 匿名内部类



### 成员内部类

**创建方式**：外部类名.内部类名  对象名 = new 外部类().内部类();

访问其他成员的方式：可以直接访问外部类的实例成员，静态成员；可以拿到当前外部类对象，格式是外部类名.this

***chy有话说：就是没有static修饰的普通内部类***



### 静态内部类

**创建方式：**外部类名.内部类名  对象名 = new 外部类.内部类();

静态内部类不能直接访问外部类的实例成员，但是可以访问外部类的静态成员

***chy有话说：就是有static修饰的内部类，访问方式和静态变量一样***





### 匿名内部类

继承了父类并重写父类的某方法，使用new创建出没有名字但继承父类的子类

使用场景：通常作为一个参数传输给方法





## 枚举

枚举是一种特殊类

![image-20231115155542899](C:\Users\83538\AppData\Roaming\Typora\typora-user-images\image-20231115155542899.png)

```java
public enum A{
    X,Y,Z;
    private String name;
    public String getName(){
        return name;
    }
    public void setName(String name)(){
        this.name = name;
    }
    
}
```

+ 枚举类的第一行只能罗列一些名称，这些名称实际上都是常量，记录的是枚举类的一个对象
+ 枚举类的构造器是私有的，对外不能创建对象
+ 枚举类是最终类，不能被继承
+ 枚举类中，从第二行开始，可以定义类的其他各种成员
+ 枚举类都是继承java.lang.Enum类的



***chy有话说：枚举类相当于提前创建好了几个对象给外部调用，所以外部不能再用枚举类的构造器创建对象了***





### 抽象枚举

在枚举类中定义了一个抽象方法，因此在第一行罗列对象的时候不能直接创建对象了，需要对抽象方法进行重写

```java
public enum A{
    X(){
        @Override
        public void go(){
            
        }
    },Y(){
        @Override
        public void go(){
            
        }
    };
    public abstract void go();
}
```



## 泛型

