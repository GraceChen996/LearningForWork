# 常用函数



# 题目



## 2.两数相加

**法一：**

+ p1指向l1,p2指向l2。
+ 进位 =（ p1.val+p2.val+上一次进位）/10；
+ 余数 =   p1.val+p2.val+上一次进位-进位*10；
+ 考虑l1和l2位数不同的情况



**法二：**

+ 分别遍历两个数组，获得他们所代表的数
+ 将两个数相加获得结果
+ 将结果构建成一个链表



**题解里比较好的写法：**

+ int n1 = l1 != null ? l1.val : 0;（如果l1不是空node，就让n1 = l1.val,否则n1=0）这样就可以将空节点视作零，无需特殊处理了



## 19.删除链表的倒数第N个结点

**法一：**快慢指针

+ 如果链表中没有结点，就返回head

+ 维护两个指针，两个指针的间隔为n
+ 当最后一个指针到达最后一个结点的时候，第一个指针刚好到达要删除的指针的上一个结点。



## 21.合并两个有序链表

**法一：**迭代

+ 设置一个哨兵节点用于标识链表头
+ 再设置一个prev节点用于标识已经创建出的链表的尾部
+ l1和l2分别指向没遍历过的链表的头部





**法二：**递归 【想不到】

+ list1[0]<list2[0]时，list1[0]+merge(list1[1],list2]
+ otherwise, list2[0] + merge(list1,list2[1:])





## 61.旋转链表

**法一：**

+ 遍历一次链表，计算出链表节点总数
+ 对k进行取余运算，判断需要旋转的次数
+ 找到旋转的节点，将上一个节点的next设置为null，将链表的最后一个节点的next设置为old head





**法二：**闭合为环 【想不到】

+ if（k==0||head==null||head.next ==null) return head【如果不旋转，或者链表中没有节点，或者链表中只有一个节点，就直接返回head】
+ 通过遍历，找到最后一个节点，将其next指向head
+ 继续遍历，直到达到旋转次数，然后记录当前节点的下一个节点为new head，将当前节点的next设置为null



## 138.随机链表的复制





## 141.环形链表

**法一：**快慢指针

+ 维护一个指针p1指向head，指针p2指向head.next
+ 循环条件为p1!=p2
+ 如果p2为null或者p2.next==null就返回false
+ 每次p1向后移动一格，p2向后移动两格
+ 如果p1和p2相遇的话，就说明存在环