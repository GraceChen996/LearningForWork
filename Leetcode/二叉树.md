# 常用函数

## 接口Queue

public interface Queue<E> extends Collection<E>

**Method：**

+ boolean add(E e)：插入元素。插入失败抛出异常

+ boolean offer(E e)：插入元素。插入失败返回false

+ E element()：获取（不删除）队列头。如果队列为空抛出NoSuchElementException异常

+ E peek()：获取（不删除）队列头。如果队列为空返回null

+ E remove()：获取并删除队首元素。如果队列为空抛出异常

+ E poll()：获取并删除队首元素。如果队列为空返回null




## LinkedList

+ addFirst
+ addLast
+ getFirst
+ getLast
+ removeFirst
+ removeLast



# 题目

## 100.相同的树

**法一：**深度优先搜索

+ 如果结点的左右子树都相同，并且结点本身的值相同，那么以这个结点为根的树就相同

**法二：**广度优先搜索 【想不到】

+ 使用两个队列分别存储两个二叉树的结点，初始状态下将两个根节点分别加入两个队列
+ 每次从队列中分别取出一个结点，比较它们的值
+ 如果两个结点值不同，则返回false
+ 如果两个结点值相同，则判断两个节点的左右结点，如果只有一个节点的左子树或右子树为空，则返回false
+ 如果两个结点的左右结点结构相同，则将节点分别加入两个队列
+ 搜索结束后如果两个队列同时为空，则两个二叉树相同



## 104.二叉树的最大深度

**法一：**深度优先搜索

+ 当前结点所在的树的最大深度=1+max（左子树最大深度，右子树最大深度）

**法二：**广度优先搜索

+ 维护一个队列，每次取出队列中所有的结点进行下一层结点的拓展
+ 用一个变量记录拓展次数，其值即为最大深度



## 105.从前序与中序遍历序列构造二叉树

**法一：**递归+哈希

+ 将中序遍历的数组元素及索引加入哈希表便于寻找
+ 将先序遍历数组的首个元素作为根节点，在哈希表中寻找该元素，返回该元素在中序数组中的下标
+ 通过以上操作可以将两个数组分别拆分为以下形式：
  + 先序：根节点 | 左子树 | 右子树
  + 中序：左子树 | 根节点 | 右子树
+ 根据获得的数组下标分别对左子树和右子树进行递归构建





## 106.从前序与中序遍历序列构造二叉树

**法一：**同105





## 112.路径总和

**法一：**深度遍历



## 114.二叉树展开为链表

**法一：**

+ 前序遍历，将节点顺序存入list
+ 遍历list，重新创建树



**法二：**寻找前驱节点 【想不到】

+ 如果一个节点的左子节点为空，则该节点不需要进行展开操作。
+ 如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点
+ 将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，将当前节点的左子节点设为空。
+ 对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。



## 117.填充每个节点的下一个右侧节点指针II

**法一：**层序遍历

+ 维护一个队列，对树进行层序遍历
+ 每次取出队列中的所有元素，当遍历到最后一个元素的时候将其next指针置为null





## 199.二叉树的右视图

**法一：**

+ 层序遍历，找到最右边的节点





## 226.翻转二叉树

**法一：**递归

+ 如果当前root！=null，就翻转以它左子树为根的树，再翻转以它右子树为根的树
+ 翻转左右子树