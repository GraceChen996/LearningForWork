# 解题模板

详情见b站视频

+ left=-1.right=n
+ while(left+1!=right)
+ if(target<mid)right=mid (而不是mid-1)
+ if(target>mid)left=mid (而不是mid+1)
+ 根据题意判断寻找的是红区还是蓝区



# 常用函数





# 题目

## 4.寻找两个正序数组的中位数

**法一：**暴力

+ 使用System.arraycopy()合并两个数组
+ 使用Arrays.sort()对数组进行排序
+ 根据元素的个数计算中位数



**法二：**双指针

+ 因为已知数组长度，所以可以知道中位数的下标
+ 维护两个指针，每次让较小的指针向后移动一位



## 33.搜索旋转排序数组

**法一：**二分查找

+ 第一次二分查找先查找出旋转的位置。如果nums[mid]>nums[left]，说明left~mid是顺序，则left=mid; 如果nums[mid]<nums[left]，说明mid~right是顺序，则right=mid；
+ 分别对两边的顺序数组进行二分查找。



## 34. 在排序数组中查找元素的第一个和最后一个位置

**法一：**二分查找 【边界条件】

+ 查找第一个>=target的元素
+ 查找第一个>target的元素





## 35.搜索插入位置

**法一：**二分查找



## 74.搜索二维矩阵

**法一：**逐层二分查找



## 153.寻找旋转排序数组中的最小值

**法一：**二分查找







## 162.寻找峰值

**法一：**哈希表

+ 遍历元素，存入哈希表，key为元素值，value为下标
+ 寻找最大的元素，返回其下标



**法二：**

+ 在[0,n)之间随机初始化一个i
+ 如果nums[i-1]<nums[i]>nums[i+1]，则i处就有一个峰值
+ 如果nums[i-1]<nums[i]<nums[i+1]，则i=i+1;
+ 如果nums[i-1]>nums[i]>nums[i+1]，则i=i-1;
+ 如果nums[i-1]>nums[i]<nums[i+1]，则朝任意方向走

