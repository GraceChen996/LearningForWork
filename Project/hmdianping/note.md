# 短信登录





## 基于Session实现

+ 发送短信验证码
  + 对用户手机号的合法性进行校验

  + 生成验证码后先保存后发送

    

+ 短信验证码登录与注册

  + 校验手机号和验证码是否匹配
  + 判断手机号是否存在以决定是否需要创建新用户

  

+ 校验登录状态

  + 从用户的请求中获取cookie以便从session种获取用户
  + 判断用户是否存在
  + 将存在的用户保存到缓存中



**基于Session的方法存在的问题：**

+ Sess

## 基于Redis实现

**session共享问题：**当在不同服务器间切换请求时会导致数据丢失的问题，因为它们不共享session存储空间。

**解决方案：**Redis可以实现不同服务器之间的数据共享，同时还是内存存储（读写速度很快）



**和Session方案的区别：**

+ 生成验证码后将验证码保存到Redis而不是Session，保存内容的Key为手机号，value为验证码
+ 保存用户到Redis时key为随机token，value为用户信息，并且将token返回给前端。
+ 校验登录状态时，前端携带token作为key，并且从redis中获取用户信息



**注意事项：**

+ 选择合适的数据结构，key，存储粒度
+ 生成code阶段：将code存储到Redis时需要设置过期时间，避免数据堆积
+ 登录校验阶段：
  + 利用hutool工具中的BeanUtil下的copyProperties方法隐藏user中的部分信息，将其转换成UserDTO对象（信息更少的对象）
  + 利用BeanUtil下的beanToMap方法获取userMap，将其存入Redis中并设置用户过期时间
+ 拦截器：
  + 设计两层拦截器，在拦截器配置表中用order设置两个拦截器的优先级
    + 拦截器1，拦截一切路径，用于刷新token有效期
    + 拦截器2，拦截需要登录的路径，如果不存在就拦截，存在就不拦截
  + 拦截器1中通过首先通过请求头中的"authorization"字段获取token，如果token不存在，说明用户没登陆过，直接放行。如果token存在，则根据token获取Redis中的用户属性。如果用户不存在，直接放行。如果用户存在，则需要用BeanUtil下 fillBeanWithMap方法构造出一个UserDTO对象，保存用户信息并刷新登录过期时间。
  + 拦截器2，查看ThreadLocal中是否存在用户，不存在则拦截，存在则放行。



## 功能优化

**登录校验拦截器**

+ 将登录校验拦截器注册到Web框架中的拦截器链中
+ 创建拦截器（继承于HandlerInterceptor类），对功能进行重写
+ 验证用户身份



**数据传输对象模式**

+ 将数据返回给前端页面时使用DTO类简化数据传输，隐藏敏感信息，同时减少传输的数据量
+ 使用BeanUtil.copyProperties静态方法批量拷贝数据



# 商户查询缓存

**方案一：不使用缓存，用户直接与数据库进行交互**

--------------

**方案二：添加缓存**

**添加Redis缓存的流程：**

+ 在客户端和数据库之间添加Redis作为中间层
+ 客户端先向Redis缓存发起请求
  + 若命中，直接获取数据
  + 若未命中，向数据库发起请求并获取数据。将数据写入Redis缓存。

**根据id查询商铺缓存的流程：**

+ 提交商铺id，从Redis中查询商铺缓存
  + 若命中，直接返回商铺信息
  + 若未命中，根据id查询数据库，判断商铺是否存在
    + 如果商铺存在，则将商铺数据写入Redis，并返回商铺信息
    + 如果商铺不存在，返回404

-----------------

**方案三：基于缓存空对象解决缓存穿透问题**

**根据id查询商铺缓存的流程：**

- 提交商铺id，从Redis中查询商铺缓存
  - 若命中，<font color=red>判断是否为空值</font>
    - 若是空值则结束操作
    - 若不是空值，则返回商铺信息
  - 若未命中，根据id查询数据库，判断商铺是否存在
    - 如果商铺存在，则将商铺数据写入Redis，并返回商铺信息
    - 如果商铺不存在，<font color=red>则将空值写入Redis</font>

---------------------

**方案四：基于互斥锁解决缓存击穿问题**

**基于互斥锁解决缓存击穿问题**：

+ 提交商铺id，从Redis中查询商铺缓存
  + 若命中，则返回商铺数据
  + 若未命中，则尝试获取互斥锁
+ 若获取互斥锁成功，则根据id获取商铺数据，将数据写入Redis，释放锁后返回数据
+ 若获取互斥锁失败，则休眠一段时间后再次尝试查询Redis中的商铺缓存

-----------------------

**方案五：基于逻辑过期解决缓存击穿问题**

+ 提交商铺id，从Redis中查询商铺缓存

  + 若未命中，则返回空（由于key设置了逻辑过期字段，所以不设置TTL，如果缓存中没有就说明数据库里也没有）

  + 若命中，判断缓存是否过期

    + 未过期则返回商铺信息
    + 过期则尝试获取互斥锁

  + 若成功获取互斥锁，则开启独立线程完成查询和写入Redis的操作，由独立线程释放锁，其自身返回缓存中的商铺信息

  + 若未成功获取互斥锁，则直接返回商铺信息



# 优惠券秒杀

### 实现秒杀下单

+ 提交优惠券id，查询优惠券信息
+ 判断秒杀是否开始
  + 未开始，返回错误信息
  + 已开始，判断库存是否充足
    + 库存不足，则返回错误信息
    + 库存充足，扣减库存，创建订单，返回订单id





### 解决超卖问题

### 实现一人一单

+ 提交优惠券id

+ 查询优惠券信息

+ 判断秒杀是否开始

  + 否，返回异常结果
  + 是，判断库存是否充足

+ 若库存不充足则返回错误结果；若库存充足，则根据优惠券id和用户id查询订单

+ 判断订单是否存在

  + 是，返回异常结果
  + 否，扣减库存

  

### 秒杀优化

**优化思路：**

在优惠券秒杀的整个业务流程当中，因为有多次写数据库的操作，如果串行执行流程的话会导致业务执行速度降低。所以考虑将串行的业务交给不同的线程处理，同时提高对秒杀资格判断的效率。

